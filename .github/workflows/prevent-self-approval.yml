name: Prevent self-approval on auto cherry-pick PRs

on:
  pull_request_review:
    types: [submitted]

permissions:
  contents: read
  pull-requests: write

jobs:
  prevent-self-approval:
    # Only run for APPROVED reviews on autocherry PRs
    if: >
      github.event.review.state == 'approved' &&
      (
        startsWith(github.event.pull_request.title, 'Auto cherry-pick:') ||
        startsWith(github.event.pull_request.head.ref, 'autocherry/')
      )
    runs-on: ubuntu-latest

    steps:
      - name: Check and dismiss self-approval if needed
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const review = context.payload.review;

            if (!pr || !review) {
              core.info('No pull_request or review in payload, nothing to do.');
              return;
            }

            // Safety: only touch auto cherry-pick PRs created by the bot
            const title = pr.title || '';
            if (!title.startsWith('Auto cherry-pick:')) {
              core.info('PR does not look like an auto cherry-pick PR. Skipping.');
              return;
            }

            const reviewer = review.user && review.user.login ? review.user.login : '';
            if (!reviewer) {
              core.info('No reviewer login, skipping.');
              return;
            }

            // --- 1) Determine original author from ORIGIN PR (source of truth) ---

            const body = pr.body || '';
            const match = body.match(/PR\s+#(\d+)/i);
            if (!match) {
              core.info('Could not parse origin PR number from body. Skipping.');
              return;
            }

            const originNumber = Number(match[1]);
            core.info(`Parsed origin PR number from body: #${originNumber}`);

            let originAuthor = '';
            try {
              const { data: originPr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: originNumber,
              });

              if (originPr.user && originPr.user.login) {
                originAuthor = originPr.user.login;
                core.info(`Original author from origin PR: "${originAuthor}"`);
              } else {
                core.info('Origin PR has no user.login, skipping.');
                return;
              }
            } catch (err) {
              core.info(`Failed to fetch origin PR #${originNumber}: ${err.message}`);
              return;
            }

            // --- 2) Optional: compare with orig-author:<login> label (for sanity) ---

            const labels = pr.labels || [];
            const marker = 'orig-author:';
            const authorLabel = labels.find(
              l => typeof l.name === 'string' && l.name.startsWith(marker)
            );

            if (authorLabel) {
              const labelAuthor = authorLabel.name.substring(marker.length).trim();
              core.info(`Label author = "${labelAuthor}", origin author = "${originAuthor}"`);
              if (labelAuthor &&
                  labelAuthor.toLowerCase() !== originAuthor.toLowerCase()) {
                core.warning(
                  `orig-author label "${labelAuthor}" does not match origin PR author "${originAuthor}".`
                );
              }
            } else {
              core.info('No orig-author label present on PR (that is OK, we rely on origin PR author).');
            }

            core.info(
              `Final check: originAuthor="${originAuthor}", reviewer="${reviewer}", state="${review.state}"`
            );

            if (review.state.toLowerCase() !== 'approved') {
              core.info('Review is not APPROVED (maybe COMMENTED / CHANGES_REQUESTED). Nothing to do.');
              return;
            }

            // --- 3) Enforce: reviewer must not be the original author ---

            if (reviewer.toLowerCase() !== originAuthor.toLowerCase()) {
              core.info('Reviewer is not the original author. Nothing to do.');
              return;
            }

            core.info('Detected self-approval on an auto cherry-pick PR. Dismissing review...');

            await github.rest.pulls.dismissReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              review_id: review.id,
              message: 'Self-approval of an auto cherry-pick PR is not allowed. Review was automatically dismissed.',
            });

            core.info('Review dismissed successfully.');
